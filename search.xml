<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS进阶使用]]></title>
    <url>%2F2019%2F06%2F08%2FJS%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[​&emsp;&emsp;这个博客想写很久了，一直拖着拖着，感觉再拖下去，自己一直打自己的脸也不太好。本来想讲一些接触到的JS的用法的，又觉得都只是API的调用，蛮简单的，所以讲了ES6和ES7语法中的一些东西。怎么说呢，原本以为自己写博客，一定能写很长的，毕竟自己当年也热爱文字，笔耕不缀，真正自己写的时候，要么感觉蛮简单，自己在说废话，要么就是不知道自己怎样下笔，也只堪堪凑了一千来字的文章，主要讲了Promise和async，await。说实话，如果我身为一名萌新，读这篇博客，可能获取不到什么收益，只希望自己能够坚持下去。假如有喜欢JS，Python以及Java的朋友，也可以一起交流~ 一，什么是Promise？​&emsp;&emsp;Promise是JS的ES6标准添加的一个新特性，众所周知，JS是一门单线程语言，写过JQ代码的都知道，某些极端情况下，会产生很多级的回调，这样就产生了回调地狱，代码维护起来十分困难（考虑某个项目需要四个请求全部完成才能算是请求正确，这样就会不得不嵌套四层回调）。因此，Promise应运而生。它是异步编程的一个解决方案，实质上Promise是一个对象，它拥有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)，并且状态一旦改变，就不会再变。话不多说，直接上代码体会。 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0) reject(2)&#125;)p.then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) ​&emsp;&emsp;让我们好好想想上面的代码会显示什么？ ​&emsp;&emsp;可能会有一部分人觉得上面的代码会打印出1，然而，实际上，上面的代码会打印出2。我们都清楚JS的事件队列机制，它会先执行同步任务，再执行异步任务。因此，在Promise的构造函数中，尽管setTimeout设置了很低的时延，但其依然是一个异步任务，同步任务的reject(2)已经抢先将Promise的状态从等待态变为了失败态，Promise的状态一旦改变，就不会再变，所以只会打印出2。 ​&emsp;&emsp;同样值得注意的是，当Promise内部的代码执行时出现了错误，也并不会抛出错误。它也会将Promise的状态设置为rejected，并将错误传递给接下来的catch的处理逻辑。Promise是一种基于状态的管理，通过状态，就可以将一些复杂的回调函数，写成then的链式调用。 ​&emsp;&emsp;Promise还有两个比较重要的使用方法，一个是Promise.all()， 一个是Promise.race()。这两个分别代表，当全部为成功时才算成功和当一个为成功时则算成功，示例代码如下。 12345678910111213141516let test1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('5s 的延时') resolve(1) &#125;, 5000)&#125;)let test2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('2s 的延时') resolve(1) &#125;, 2000)&#125;)Promise.all([test1, test2]).then(res =&gt; &#123; console.log('all成功执行！')&#125;) ​&emsp;&emsp;上面的代码返回值应当是这样的： 1232s 的延时5s 的延时all成功执行！ ​&emsp;&emsp;如果将Promise.all改为Promise.race，则将是下面这样的： 1232s 的延时5s 的延时all成功执行！ ​&emsp;&emsp;Promise理解了之后还是挺简单的，挺好用的。不过虽然Promise相较于之前的回调函数，代码的可看性有了很大的改观，但是还是不够爽。而且假设有一个极端的情况，四个请求ABCD，要求必须按顺序，得到返回值之后才能执行下一个，如果使用Promise还是不咋美观，这个时候就需要ES7的async和await的出场了。 二，async和await​&emsp;&emsp;async顾名思义，即声明一个函数是异步函数，而await则是在异步函数中等待一个异步任务完成，直到执行完成后，再继续执行下面的代码。await关键字只能够在async函数中使用，而不能直接使用。async和await可以让我们用编写同步任务代码的方式来编写异步任务代码，可以说，学会这一大法，编写JS代码的幸福感瞬间提升无数倍（才怪）。 ​&emsp;&emsp;首先让我们来看一个小栗子： 123456789101112131415let sleep = (time) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`延迟了$&#123;time&#125;s`) resolve(time) &#125;, time) &#125;)&#125; let test = async () =&gt; &#123; let res = await sleep(1000) console.log(res)&#125;test()console.log('同步任务还是最先执行到的。') ​&emsp;&emsp;上面一段代码最终执行效果如下： 123同步任务还是最先执行到的。延迟了1000s1000 ​&emsp;&emsp;上面的显示结果告诉我们，不管怎么说，JS代码执行的时候，同步代码都是一等公民，怎么着都得先执行（DOM的操作也是同步任务，但是DOM渲染不是）。但是当执行一个声明了的异步函数的时候，await会在异步函数执行完成后，继续执行下面的代码。 ​&emsp;&emsp;如果我们打印上面的test函数，我们会发现，实质上async关键字返回的是一个Promise对象。所以，如果async函数需要取到它的返回值的话，需要像操作Promise对象一样，在then中取到，不能直接取到。 ​&emsp;&emsp;想说得挺多的，然而写得时候，却不知道写什么，如果有什么问题，欢迎一起交流。]]></content>
      <tags>
        <tag>-JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring security注册后登录]]></title>
    <url>%2F2019%2F03%2F01%2Fspring-security%E6%B3%A8%E5%86%8C%E5%90%8E%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[​ 之前曾经写过一个Demo，其中有个需求是完成注册后自动登录。实际应用场景中，我们自然不可能让用户注册后，再使用注册后的账户和密码重新登录一次，个人觉得这是一个不怎么人性化的操作。当我们使用Spring security框架进行开发的时候，虽然默认提供了有记住登录的功能，但是却没有提供注册后登录的配置，我就查询了百度的相关资料。然而，这个时候，如果你和我一样有同样的需求，你就会发现，百度上的代码都是用不了的。不知道是由于年代久远，还是各种博客互相抄袭，解决的方案基本一致，然而代码全都不能用。 ​ 如果对Spring security框架有一定的了解，就知道Spring security是把登录的用户存储到session中，如果session中存储了有Authentication则证明该用户已登录。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F01%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python，俗称蟒蛇。是由Guido van Rossum圣诞节无聊，打发时间鼓捣出的一种脚本语言（Linus休息的时候写出来git，成就了现在如日中天的GitHub，可见大佬们都是无敌的）。历经多年的发展，借着人工智能的浪潮，已经成为了世界上最火爆的语言之一。python的优点在于它的语法十分简洁，据说，实现同样的功能，python的代码量只是JAVA的五分之一。不过，python的执行效率也一直饱受诟病，这也是python一直不够火的原因。当然，这一切都随着计算机性能的大幅度提升成为了过去式。现在而言，对于很多公司来说，重要的是快速迭代，因而，python成为了首选。例如著名的网站——豆瓣，就是采用python制作的。 python的安装及环境配置windows安装打开python官网，选择Downloads，会出现如下界面 选择Python3.7.2进行下载安装即可。 下载之后，双击安装，与安装其它软件并无差别。唯一的不同是，双击安装，进入安装页面后，请务必记得勾选Add To Path，这样才能在CMD中打开python。 linux安装macos安装 python基本语法安装完毕python之后，则可以在命令行中输入python后回车（也可以打开IDLE）进行交互式操作（windows系统按住shift，然后点击鼠标右键，会有一个在此处打开命令行窗口或者powershell，点击即可进入命令行）。 进入python后的显示界面如下： 如此显示，则代表成功启动python。 python的数据类型python是一门弱数据类型语言，即它定义一个变量的时候，并不需要声明该变量的数据类型。在python中有六种基本的数据类型，分别是Number(数字),String(字符串),Tuple(元组),List(列表),Dictionary(字典),Set(集合)。其中前三种属于不可变数据，后三种属于可变数据。下面讲解六种基本数据类型。 Number类型int类型int类型即整型，是数字5，10，这样没有小数点的类型。 123&gt;&gt;&gt;a = 5&gt;&gt;&gt;type(a)&lt;class 'int'&gt; float类型float类型即浮点型，是5.0，4.5这样有小数点的类型。 123&gt;&gt;&gt;a = 4.3&gt;&gt;&gt;type(a)&lt;class 'float'&gt; complex类型complex类型复数类型，是类似于4+5j这样的数。 123&gt;&gt;&gt;a = 5+4j&gt;&gt;&gt;type(a)&lt;class 'complex'&gt; bool类型bool类型是布尔类型，该类型只有False和True两个值。 123&gt;&gt;&gt;a = True&gt;&gt;&gt;type(a)&lt;class 'bool'&gt; 布尔类型虽然表示逻辑，但是可以直接与数字进行计算。True 的值为1，False的值为0。 123&gt;&gt;&gt;a, b= True, 1 #对a，b两个变量分别赋值，a为True，b为1&gt;&gt;&gt;a + b2 string类型string类型即字符串类型，python中的字符串被单引号’’或者双引号“”括起来，同时使用\转义特殊字符。两个字符串可以直接拼接，这样就产生了一个新的字符串。同时在python中，string类型可以方便的剪切，可以使用形如 变量[头下标:尾下标]的代码进行字符串剪接。 1234567891011121314151617181920&gt;&gt;&gt;w = '赵襄' #双引号与单引号并无区别&gt;&gt;&gt;w #也可以使用print(w)打印，直接s仅限于交互窗口'赵襄'&gt;&gt;&gt;z = '襄襄'&gt;&gt;&gt;wz = w + z&gt;&gt;&gt;print(wz)'赵襄襄襄'&gt;&gt;&gt;wz[0:1] #所有的编程语言中，第一个字符都是由0开始算的。'襄'&gt;&gt;&gt;wz[0:-1] #-1表示从尾部数起'赵襄襄'&gt;&gt;&gt;wz[0] #如同wz[0:1]，如果没有尾下标，则将处于头下标的字符输出。'襄'&gt;&gt;&gt;wz*2 #python中字符串可以使用乘法，表示将该字符串复制n遍'赵襄襄襄赵襄襄襄'&gt;&gt;&gt;wz[1:3]*2 #也可以混合一起用，python是一门胶水语言'襄襄襄襄'&gt;&gt;&gt;print(wz+'\n123') #\后跟字符会将字符转义，\n即是回车，必须加print，不然默认交互界面是不转义的赵襄襄襄123 tuple类型tuple类型即元组类型，tuple类型和list类型十分相似，唯一的区别是list里面的元素可以改变，而元组不能。同时元组，列表索引的方式，与string是一模一样的。元组的定义是用小括号()包围。 12345678910111213141516171819&gt;&gt;&gt;tuple = ( 'abcd', 786 , 2.23, '阿襄', 70.2 )&gt;&gt;&gt;tinytuple = (123, '阿襄') &gt;&gt;&gt;print (tuple) # 输出完整元组('abcd', 786 , 2.23, '阿襄', 70.2)&gt;&gt;&gt;print (tuple[0]) # 输出元组的第一个元素abcd&gt;&gt;&gt;print (tuple[1:3]) # 输出从第二个元素开始到第三个元素(786, 2.23)&gt;&gt;&gt;print (tuple[2:]) # 输出从第三个元素开始的所有元素(2.23, '阿襄'， 70.2)&gt;&gt;&gt;print (tinytuple * 2) # 输出两次元组(123, '阿襄', 123, '阿襄')&gt;&gt;&gt;print (tuple + tinytuple) # 连接元组( 'abcd', 786 , 2.23, '阿襄', 70.2 , 123, '阿襄')&gt;&gt;&gt;tinytuple[1] = '襄襄' #修改元组的元素会报错，就算修改后和修改前一样也是如此Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment list类型list类型即列表类型，与tuple十分相似，不多赘述。 12345678910111213141516171819202122&gt;&gt;&gt;list = [ 'abcd', 786 , 2.23, '阿襄', 70.2 ]&gt;&gt;&gt;tinylist = [123, '阿襄'] &gt;&gt;&gt;print (list) # 输出完整列表['abcd', 786 , 2.23, '阿襄', 70.2]&gt;&gt;&gt;print (list[0]) # 输出列表第一个元素abcd&gt;&gt;&gt;print (list[1:3]) # 从第二个开始输出到第三个元素[786 , 2.23]&gt;&gt;&gt;print (list[2:]) # 输出从第三个元素开始的所有元素[2.23, '阿襄', 70.2]&gt;&gt;&gt;print (tinylist * 2) # 输出两次列表['abcd', 786 , 2.23, '阿襄', 70.2, 'abcd', 786 , 2.23, '阿襄', 70.2]&gt;&gt;&gt;print (list + tinylist) # 连接列表['abcd', 786 , 2.23, '阿襄', 70.2, 123, '阿襄']&gt;&gt;&gt;list[3] = '襄襄' #与tuple不同，list的元素值可以被改变&gt;&gt;&gt;print(list)[ 'abcd', 786 , 2.23, '襄襄', 70.2 ]&gt;&gt;&gt;list[1:3] = [777, 223, '赵襄'] #同时也可以使用索引批量更改[ 'abcd', 777, 223, '赵襄', 70.2 ] set类型set类型是集合类型，基本操作与tuple和list一致。 1234567891011121314151617&gt;&gt;&gt;student = &#123;'赵襄', '阿襄', '襄襄', '赵襄'&#125; &gt;&gt;&gt;print(student) # 输出集合，重复的元素被自动去掉&#123;'赵襄', '阿襄', '襄襄'&#125; # set可以进行集合运算&gt;&gt;&gt;a = set('abracadabra')&gt;&gt;&gt;b = set('alacazam')&gt;&gt;&gt;print(a) #顺序可能不一样&#123;'a', 'd', 'r', 'b', 'c'&#125; &gt;&gt;&gt;print(a - b) # a 和 b 的差集&#123;'b', 'd', 'r'&#125;&gt;&gt;&gt;print(a | b) # a 和 b 的并集&#123;'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'&#125;&gt;&gt;&gt;print(a &amp; b) # a 和 b 的交集&#123;'a', 'c'&#125;&gt;&gt;&gt;print(a ^ b) # a 和 b 中不同时存在的元素&#123;'l', 'r', 'z', 'm', 'b', 'd'&#125; Tips:特别注意，如果创建一个空集合，不能使用a={}，而应当使用a=set()，前者默认是创建一个空的字典，而非一个空的集合。 dictionary类型dictionary是字典类型，类似于平常的字典。主要存储的是键值对（key-value），主要通过key来获取value。 1234567891011121314151617dict = &#123;&#125;dict['wz'] = "赵襄"dict[2] = "阿襄" tinydict = &#123;'name': '赵襄','age':16, 'like': '道'&#125; print (dict['wz']) # 输出键为 'wz' 的值赵襄print (dict[2]) # 输出键为 2 的值阿襄print (tinydict) # 输出完整的字典&#123;'name': '赵襄','age': 21, 'like': '诗'&#125;print (tinydict.keys()) # 输出所有键dict_keys(['name', 'age', 'like'])print (tinydict.values()) # 输出所有值dict_values(['赵襄', 21, '诗'])]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poem]]></title>
    <url>%2F2018%2F12%2F20%2Fpoem%2F</url>
    <content type="text"><![CDATA[打算创建一个关于诗歌的网站。]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
