<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES诗词分析]]></title>
    <url>%2F2019%2F06%2F16%2FES%E8%AF%97%E8%AF%8D%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;诗词的兴盛，就算按照诗谱序所言，不于上皇之世，到现在也有个几千年了。然而诗经不过三百余首，煊赫的唐诗，也才四五万首左右。到了当代，写诗的人数相较于唐宋之时，可以说是远迈了。然而当代旧体诗词数量众多，质量参差不齐。于是，身为一名菜鸟数据工程师，爬取了52诗词网上的两万首诗词作为源数据，略分析一下52诗词网上的公开诗词。 &emsp;&emsp;首先，我必须指出的是，因为吾爱诗词网的内容实在是太乱了，也不好找出一个统一的过滤数据的方式，因而部分数据并不十分严谨，同时可能还存在相同数据的情况（忘了除重了），万忘见宥。 &emsp;&emsp;当爬完数据的时候，不得不说，当代人实在是非常能写。2w首是什么概念呢？它大约是全唐诗的百分之四十，全宋诗的百分之八。但它在当代，实在不足一提，犹如沧海一粟，它只是从半年里吾爱诗词网的闲咏杂谈栏目的数据量。这仅仅是吾爱诗词网的数据而已，不包括其它诗词类网站，更何况，我认识的人中，使用吾爱的人寥寥无几。如此看来，当代的诗歌数量印成书，那便是厚厚的一堆了。 &emsp;&emsp;与数量多相反的是，粗略浏览之下，诗词的质量并不高，甚至可以说很低。因为吾爱诗词网的受众主要是中老年人，这一定程度上也可以说是审美的差异（其中不乏一些注释写得贼偏得，不知道是不是自动注释功能得作用）。从内容来看，其主要体现的是我写我，口语化现象十分严重，也没有什么诗歌技巧。如果将它们与唐宋相比，自然是远远不及，但个人认为，从新文化运动之后，旧体诗词就很难再有复兴，写得好与写得差，都是自娱居多。清华大学得人工智能小组有一个九歌项目，我觉得大概吾爱诗词网得普遍水平可能还不如作诗机。刘慈欣有一篇科幻小说《诗云》，里面更高维度的文明能够穷尽所有诗的可能，而人类不过是海边的拾贝人，期待哪一天能够捡到一块漂亮的，从而暴得大名。被海冲到浪边的贝壳毕竟是少数，唐人宋人捡了很多走了，到今人恐怕就捡不到什么了（莫名想到了比特币）。 &emsp;&emsp;同时，对数据源进行聚合之后发现，仅半年之内，就有四名作者发表的诗歌数量超过180，勤加努力，尚有机会超越十全老人（记得去年看到某位官员的诗集，数量高达两万余首，都是强者）。然后，可能大家平时自己写诗都没有什么感觉，到底自己写诗的时候，用什么字最多，这次专门对诗歌内容进行了分词聚合，只对单词和双词进行了匹配，发现，二者最火的词分别如下。 单词柱状图双词柱状图 &emsp;&emsp;当然，以上的表是有一些问题的，尤其是一的数量。19856首诗中，含有一字的大约是7386首。其中有相当一部分的数据是因为源数据中自己填写了韵表之类的一些信息，导致一的数量虚高。但是，就算去除这部分数据，一仍然是当之无愧的第一，因为它的优势太大了。其它的基本是诗句内容中含有该字的数量，其它类似于七，绝，新韵，十一，有感一类的词均被剔除了排名资格。所以说呢，这部分数据当是可信的。可见，春风，人生这种词，真得是烂大街级别，类似于什么袖手？？？凭栏？？？还有相思这个词，某位博主的文中，它是排在第一的，我随便爬的数据中，相思出现的次数也在前五。果然甜甜的爱情是每个人，每个年龄段都期待的，呜呜呜，我酸了，你们呢，啥时候甜甜的爱情才能降临到我的头上鸭。 &emsp;&emsp;由于时间比较紧，也还没有想好从哪些维度进行分析，所以授人以鱼不如授人以渔，还是把源码贴一下，感兴趣的朋友可以自行尝试。吾爱诗词网还是挺好爬的，没有针对爬虫做任何限制，各位可以尝试一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Spider52 extends BaseSpider&#123; constructor() &#123; super(&#123;baseUrl: 'http://www.52shici.com/', name: '52诗词爬虫'&#125;) &#125; async getPoemUrlList(url) &#123; let _this = this; for (let i = 0; i &lt; 400; i++) &#123; let targetUrl = this.baseUrl + url + '?type=20&amp;page=' + i; let res = await axios.get(targetUrl); let $ = cheerio.load(res); $('ul#listWorks li a').each( async function() &#123; let poemObj = await _this.getPoemFromPage($(this).attr('href')); try&#123; Poem.create(poemObj).then(res =&gt; &#123; console.log('成功！', JSON.stringify(poemObj)) &#125;).catch(err =&gt; &#123; console.log('失败~', err) &#125;) &#125;catch (e) &#123; console.log('发生了一个错误-------------------', e) &#125; &#125;); &#125; &#125; async getPoemFromPage(url) &#123; let targetUrl = this.baseUrl + url; let res = await axios.get(targetUrl); let $ = cheerio.load(res); let content = $('div#worksContent').text(); let title = $('div.works-h1 em').text().trim(); let authorSelectText = $('span.author').text().trim(); let authorArr = authorSelectText.split(/\s+/); let subType = authorArr[0] &amp;&amp; authorArr[0].slice(1, authorArr[0].length - 1); let authorName = authorArr[1] &amp;&amp; authorArr[1].slice(2); let createTime = $('em.time').text().trim(); let ofPortfolio = $('a.collection_link').text().trim(); let desc = $('p.works-intro').text().trim(); let poetryType = getPoemType(subType); return &#123; pullTime: moment().format('YYYY-MM-DD HH:mm:ss'), content, title, subType, authorName, createTime, ofPortfolio, appreciation: '', desc, poetryType &#125; &#125; async analysis() &#123; await Poem.sync(&#123;force: true&#125;); await this.getPoemUrlList('original.php?type=20'); &#125;&#125; &emsp;&emsp;主要使用了axios（http请求），cheerio（DOM操作），sequelize（ORM框架）三个库，大家可以自行尝试。]]></content>
      <categories>
        <category>-数据分析</category>
      </categories>
      <tags>
        <tag>-JS -ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶使用]]></title>
    <url>%2F2019%2F06%2F08%2FJS%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[​&emsp;&emsp;这个博客想写很久了，一直拖着拖着，感觉再拖下去，自己一直打自己的脸也不太好。本来想讲一些接触到的JS的用法的，又觉得都只是API的调用，蛮简单的，所以讲了ES6和ES7语法中的一些东西。怎么说呢，原本以为自己写博客，一定能写很长的，毕竟自己当年也热爱文字，笔耕不缀，真正自己写的时候，要么感觉蛮简单，自己在说废话，要么就是不知道自己怎样下笔，也只堪堪凑了一千来字的文章，主要讲了Promise和async，await。说实话，如果我身为一名萌新，读这篇博客，可能获取不到什么收益，只希望自己能够坚持下去。假如有喜欢JS，Python以及Java的朋友，也可以一起交流~ 一，什么是Promise？​&emsp;&emsp;Promise是JS的ES6标准添加的一个新特性，众所周知，JS是一门单线程语言，写过JQ代码的都知道，某些极端情况下，会产生很多级的回调，这样就产生了回调地狱，代码维护起来十分困难（考虑某个项目需要四个请求全部完成才能算是请求正确，这样就会不得不嵌套四层回调）。因此，Promise应运而生。它是异步编程的一个解决方案，实质上Promise是一个对象，它拥有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)，并且状态一旦改变，就不会再变。话不多说，直接上代码体会。 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0) reject(2)&#125;)p.then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) ​&emsp;&emsp;让我们好好想想上面的代码会显示什么？ ​&emsp;&emsp;可能会有一部分人觉得上面的代码会打印出1，然而，实际上，上面的代码会打印出2。我们都清楚JS的事件队列机制，它会先执行同步任务，再执行异步任务。因此，在Promise的构造函数中，尽管setTimeout设置了很低的时延，但其依然是一个异步任务，同步任务的reject(2)已经抢先将Promise的状态从等待态变为了失败态，Promise的状态一旦改变，就不会再变，所以只会打印出2。 ​&emsp;&emsp;同样值得注意的是，当Promise内部的代码执行时出现了错误，也并不会抛出错误。它也会将Promise的状态设置为rejected，并将错误传递给接下来的catch的处理逻辑。Promise是一种基于状态的管理，通过状态，就可以将一些复杂的回调函数，写成then的链式调用。 ​&emsp;&emsp;Promise还有两个比较重要的使用方法，一个是Promise.all()， 一个是Promise.race()。这两个分别代表，当全部为成功时才算成功和当一个为成功时则算成功，示例代码如下。 12345678910111213141516let test1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('5s 的延时') resolve(1) &#125;, 5000)&#125;)let test2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('2s 的延时') resolve(1) &#125;, 2000)&#125;)Promise.all([test1, test2]).then(res =&gt; &#123; console.log('all成功执行！')&#125;) ​&emsp;&emsp;上面的代码返回值应当是这样的： 1232s 的延时5s 的延时all成功执行！ ​&emsp;&emsp;如果将Promise.all改为Promise.race，则将是下面这样的： 1232s 的延时5s 的延时all成功执行！ ​&emsp;&emsp;Promise理解了之后还是挺简单的，挺好用的。不过虽然Promise相较于之前的回调函数，代码的可看性有了很大的改观，但是还是不够爽。而且假设有一个极端的情况，四个请求ABCD，要求必须按顺序，得到返回值之后才能执行下一个，如果使用Promise还是不咋美观，这个时候就需要ES7的async和await的出场了。 二，async和await​&emsp;&emsp;async顾名思义，即声明一个函数是异步函数，而await则是在异步函数中等待一个异步任务完成，直到执行完成后，再继续执行下面的代码。await关键字只能够在async函数中使用，而不能直接使用。async和await可以让我们用编写同步任务代码的方式来编写异步任务代码，可以说，学会这一大法，编写JS代码的幸福感瞬间提升无数倍（才怪）。 ​&emsp;&emsp;首先让我们来看一个小栗子： 123456789101112131415let sleep = (time) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`延迟了$&#123;time&#125;s`) resolve(time) &#125;, time) &#125;)&#125; let test = async () =&gt; &#123; let res = await sleep(1000) console.log(res)&#125;test()console.log('同步任务还是最先执行到的。') ​&emsp;&emsp;上面一段代码最终执行效果如下： 123同步任务还是最先执行到的。延迟了1000s1000 ​&emsp;&emsp;上面的显示结果告诉我们，不管怎么说，JS代码执行的时候，同步代码都是一等公民，怎么着都得先执行（DOM的操作也是同步任务，但是DOM渲染不是）。但是当执行一个声明了的异步函数的时候，await会在异步函数执行完成后，继续执行下面的代码。 ​&emsp;&emsp;如果我们打印上面的test函数，我们会发现，实质上async关键字返回的是一个Promise对象。所以，如果async函数需要取到它的返回值的话，需要像操作Promise对象一样，在then中取到，不能直接取到。 ​&emsp;&emsp;想说得挺多的，然而写得时候，却不知道写什么，如果有什么问题，欢迎一起交流。]]></content>
      <tags>
        <tag>-JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring security注册后登录]]></title>
    <url>%2F2019%2F03%2F01%2Fspring-security%E6%B3%A8%E5%86%8C%E5%90%8E%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[​ 之前曾经写过一个Demo，其中有个需求是完成注册后自动登录。实际应用场景中，我们自然不可能让用户注册后，再使用注册后的账户和密码重新登录一次，个人觉得这是一个不怎么人性化的操作。当我们使用Spring security框架进行开发的时候，虽然默认提供了有记住登录的功能，但是却没有提供注册后登录的配置，我就查询了百度的相关资料。然而，这个时候，如果你和我一样有同样的需求，你就会发现，百度上的代码都是用不了的。不知道是由于年代久远，还是各种博客互相抄袭，解决的方案基本一致，然而代码全都不能用。 ​ 如果对Spring security框架有一定的了解，就知道Spring security是把登录的用户存储到session中，如果session中存储了有Authentication则证明该用户已登录。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F01%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python，俗称蟒蛇。是由Guido van Rossum圣诞节无聊，打发时间鼓捣出的一种脚本语言（Linus休息的时候写出来git，成就了现在如日中天的GitHub，可见大佬们都是无敌的）。历经多年的发展，借着人工智能的浪潮，已经成为了世界上最火爆的语言之一。python的优点在于它的语法十分简洁，据说，实现同样的功能，python的代码量只是JAVA的五分之一。不过，python的执行效率也一直饱受诟病，这也是python一直不够火的原因。当然，这一切都随着计算机性能的大幅度提升成为了过去式。现在而言，对于很多公司来说，重要的是快速迭代，因而，python成为了首选。例如著名的网站——豆瓣，就是采用python制作的。 python的安装及环境配置windows安装打开python官网，选择Downloads，会出现如下界面 选择Python3.7.2进行下载安装即可。 下载之后，双击安装，与安装其它软件并无差别。唯一的不同是，双击安装，进入安装页面后，请务必记得勾选Add To Path，这样才能在CMD中打开python。 linux安装macos安装 python基本语法安装完毕python之后，则可以在命令行中输入python后回车（也可以打开IDLE）进行交互式操作（windows系统按住shift，然后点击鼠标右键，会有一个在此处打开命令行窗口或者powershell，点击即可进入命令行）。 进入python后的显示界面如下： 如此显示，则代表成功启动python。 python的数据类型python是一门弱数据类型语言，即它定义一个变量的时候，并不需要声明该变量的数据类型。在python中有六种基本的数据类型，分别是Number(数字),String(字符串),Tuple(元组),List(列表),Dictionary(字典),Set(集合)。其中前三种属于不可变数据，后三种属于可变数据。下面讲解六种基本数据类型。 Number类型int类型int类型即整型，是数字5，10，这样没有小数点的类型。 123&gt;&gt;&gt;a = 5&gt;&gt;&gt;type(a)&lt;class 'int'&gt; float类型float类型即浮点型，是5.0，4.5这样有小数点的类型。 123&gt;&gt;&gt;a = 4.3&gt;&gt;&gt;type(a)&lt;class 'float'&gt; complex类型complex类型复数类型，是类似于4+5j这样的数。 123&gt;&gt;&gt;a = 5+4j&gt;&gt;&gt;type(a)&lt;class 'complex'&gt; bool类型bool类型是布尔类型，该类型只有False和True两个值。 123&gt;&gt;&gt;a = True&gt;&gt;&gt;type(a)&lt;class 'bool'&gt; 布尔类型虽然表示逻辑，但是可以直接与数字进行计算。True 的值为1，False的值为0。 123&gt;&gt;&gt;a, b= True, 1 #对a，b两个变量分别赋值，a为True，b为1&gt;&gt;&gt;a + b2 string类型string类型即字符串类型，python中的字符串被单引号’’或者双引号“”括起来，同时使用\转义特殊字符。两个字符串可以直接拼接，这样就产生了一个新的字符串。同时在python中，string类型可以方便的剪切，可以使用形如 变量[头下标:尾下标]的代码进行字符串剪接。 1234567891011121314151617181920&gt;&gt;&gt;w = '赵襄' #双引号与单引号并无区别&gt;&gt;&gt;w #也可以使用print(w)打印，直接s仅限于交互窗口'赵襄'&gt;&gt;&gt;z = '襄襄'&gt;&gt;&gt;wz = w + z&gt;&gt;&gt;print(wz)'赵襄襄襄'&gt;&gt;&gt;wz[0:1] #所有的编程语言中，第一个字符都是由0开始算的。'襄'&gt;&gt;&gt;wz[0:-1] #-1表示从尾部数起'赵襄襄'&gt;&gt;&gt;wz[0] #如同wz[0:1]，如果没有尾下标，则将处于头下标的字符输出。'襄'&gt;&gt;&gt;wz*2 #python中字符串可以使用乘法，表示将该字符串复制n遍'赵襄襄襄赵襄襄襄'&gt;&gt;&gt;wz[1:3]*2 #也可以混合一起用，python是一门胶水语言'襄襄襄襄'&gt;&gt;&gt;print(wz+'\n123') #\后跟字符会将字符转义，\n即是回车，必须加print，不然默认交互界面是不转义的赵襄襄襄123 tuple类型tuple类型即元组类型，tuple类型和list类型十分相似，唯一的区别是list里面的元素可以改变，而元组不能。同时元组，列表索引的方式，与string是一模一样的。元组的定义是用小括号()包围。 12345678910111213141516171819&gt;&gt;&gt;tuple = ( 'abcd', 786 , 2.23, '阿襄', 70.2 )&gt;&gt;&gt;tinytuple = (123, '阿襄') &gt;&gt;&gt;print (tuple) # 输出完整元组('abcd', 786 , 2.23, '阿襄', 70.2)&gt;&gt;&gt;print (tuple[0]) # 输出元组的第一个元素abcd&gt;&gt;&gt;print (tuple[1:3]) # 输出从第二个元素开始到第三个元素(786, 2.23)&gt;&gt;&gt;print (tuple[2:]) # 输出从第三个元素开始的所有元素(2.23, '阿襄'， 70.2)&gt;&gt;&gt;print (tinytuple * 2) # 输出两次元组(123, '阿襄', 123, '阿襄')&gt;&gt;&gt;print (tuple + tinytuple) # 连接元组( 'abcd', 786 , 2.23, '阿襄', 70.2 , 123, '阿襄')&gt;&gt;&gt;tinytuple[1] = '襄襄' #修改元组的元素会报错，就算修改后和修改前一样也是如此Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment list类型list类型即列表类型，与tuple十分相似，不多赘述。 12345678910111213141516171819202122&gt;&gt;&gt;list = [ 'abcd', 786 , 2.23, '阿襄', 70.2 ]&gt;&gt;&gt;tinylist = [123, '阿襄'] &gt;&gt;&gt;print (list) # 输出完整列表['abcd', 786 , 2.23, '阿襄', 70.2]&gt;&gt;&gt;print (list[0]) # 输出列表第一个元素abcd&gt;&gt;&gt;print (list[1:3]) # 从第二个开始输出到第三个元素[786 , 2.23]&gt;&gt;&gt;print (list[2:]) # 输出从第三个元素开始的所有元素[2.23, '阿襄', 70.2]&gt;&gt;&gt;print (tinylist * 2) # 输出两次列表['abcd', 786 , 2.23, '阿襄', 70.2, 'abcd', 786 , 2.23, '阿襄', 70.2]&gt;&gt;&gt;print (list + tinylist) # 连接列表['abcd', 786 , 2.23, '阿襄', 70.2, 123, '阿襄']&gt;&gt;&gt;list[3] = '襄襄' #与tuple不同，list的元素值可以被改变&gt;&gt;&gt;print(list)[ 'abcd', 786 , 2.23, '襄襄', 70.2 ]&gt;&gt;&gt;list[1:3] = [777, 223, '赵襄'] #同时也可以使用索引批量更改[ 'abcd', 777, 223, '赵襄', 70.2 ] set类型set类型是集合类型，基本操作与tuple和list一致。 1234567891011121314151617&gt;&gt;&gt;student = &#123;'赵襄', '阿襄', '襄襄', '赵襄'&#125; &gt;&gt;&gt;print(student) # 输出集合，重复的元素被自动去掉&#123;'赵襄', '阿襄', '襄襄'&#125; # set可以进行集合运算&gt;&gt;&gt;a = set('abracadabra')&gt;&gt;&gt;b = set('alacazam')&gt;&gt;&gt;print(a) #顺序可能不一样&#123;'a', 'd', 'r', 'b', 'c'&#125; &gt;&gt;&gt;print(a - b) # a 和 b 的差集&#123;'b', 'd', 'r'&#125;&gt;&gt;&gt;print(a | b) # a 和 b 的并集&#123;'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'&#125;&gt;&gt;&gt;print(a &amp; b) # a 和 b 的交集&#123;'a', 'c'&#125;&gt;&gt;&gt;print(a ^ b) # a 和 b 中不同时存在的元素&#123;'l', 'r', 'z', 'm', 'b', 'd'&#125; Tips:特别注意，如果创建一个空集合，不能使用a={}，而应当使用a=set()，前者默认是创建一个空的字典，而非一个空的集合。 dictionary类型dictionary是字典类型，类似于平常的字典。主要存储的是键值对（key-value），主要通过key来获取value。 1234567891011121314151617dict = &#123;&#125;dict['wz'] = "赵襄"dict[2] = "阿襄" tinydict = &#123;'name': '赵襄','age':16, 'like': '道'&#125; print (dict['wz']) # 输出键为 'wz' 的值赵襄print (dict[2]) # 输出键为 2 的值阿襄print (tinydict) # 输出完整的字典&#123;'name': '赵襄','age': 21, 'like': '诗'&#125;print (tinydict.keys()) # 输出所有键dict_keys(['name', 'age', 'like'])print (tinydict.values()) # 输出所有值dict_values(['赵襄', 21, '诗'])]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poem]]></title>
    <url>%2F2018%2F12%2F20%2Fpoem%2F</url>
    <content type="text"><![CDATA[打算创建一个关于诗歌的网站。]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
